#! /usr/bin/env nix-shell
#! nix-shell -i bash -p bash_5 -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/ce6aa13369b667ac2542593170993504932eb836.tar.gz

# the comments above^ are special
#   they tell the system to process this using nix-shell
#   specifically using the exact version of bash to use

# summary
#     with no arguments, this simply starts an interactive shell
#     with an argument
#         it starts the shell
#         runs the arguments as if they were a command+arguments
#         then exits the shell

# 
# find the fornix_core
# 
if [ -z "$FORNIX_FOLDER" ]
then
    path_to_fornix_core=""
    file_name="settings/fornix_core"
    folder_to_look_in="$PWD"
    while :
    do
        # check if file exists
        if [ -f "$folder_to_look_in/$file_name" ]
        then
            path_to_fornix_core="$folder_to_look_in/$file_name"
            break
        else
            if [ "$folder_to_look_in" = "/" ]
            then
                break
            else
                folder_to_look_in="$(dirname "$folder_to_look_in")"
            fi
        fi
    done
    if [ -z "$path_to_fornix_core" ]
    then
        #
        # what to do if file never found
        #
        echo "Im a script running with a pwd of:$PWD"
        echo "Im looking for settings/fornix_core in a parent folder"
        echo "Im exiting now because I wasnt able to find it"
        echo "thats all the information I have"
        exit
    fi
    export FORNIX_NEXT_RUN_DONT_DO_MANUAL_START="true"
    . "$path_to_fornix_core"
fi
if [ "$FORNIX_DEBUG" = "true" ]; then
    echo "starting: $FORNIX_COMMANDS_FOLDER"shell
fi

# if no arguments (just starting the shell) give the welcome message
export FORNIX_ARGS="$@"

#
# find and run all the startup scripts in alphabetical order
#

# source all the file in settings/during_clean/ in alphabetical order
which_folder="$FORNIX_FOLDER/settings/during_start_prep"
# 
# find and run all the startup scripts in alphabetical order
#
# this loop is so stupidly complicated because of many inherent-to-shell reasons, for example: https://stackoverflow.com/questions/13726764/while-loop-subshell-dilemma-in-bash
if [ "$FORNIX_DEBUG" = "true" ]; then
    echo "triggering: $(basename "$which_folder")"
fi
mkdir -p "$which_folder"
item_paths=""
for_each_item_in="$which_folder"
[ -z "$__NESTED_WHILE_COUNTER" ] && __NESTED_WHILE_COUNTER=0;__NESTED_WHILE_COUNTER="$((__NESTED_WHILE_COUNTER + 1))"; trap 'rm -rf "$__temp_var__temp_folder"' EXIT; __temp_var__temp_folder="$(mktemp -d)"; mkfifo "$__temp_var__temp_folder/pipe_for_while_$__NESTED_WHILE_COUNTER"; (find -L "$for_each_item_in" ! -path . -print0 2>/dev/null | sort -z > "$__temp_var__temp_folder/pipe_for_while_$__NESTED_WHILE_COUNTER" &); while read -d $'\0' each
do
    item_paths="$item_paths:$each"
done < "$__temp_var__temp_folder/pipe_for_while_$__NESTED_WHILE_COUNTER";__NESTED_WHILE_COUNTER="$((__NESTED_WHILE_COUNTER - 1))"

prev_ifs="$IFS"
desired_ifs=":"
IFS="$desired_ifs"
for each in $item_paths; do
    # check if file exists
    if [ -f "$each" ]
    then
        if [ "$FORNIX_DEBUG" = "true" ]
        then
            echo "    loading: $each"
        fi
        IFS="$prev_ifs"
        . "$each" "$@"
        IFS="$desired_ifs"
    fi
done
IFS="$prev_ifs"


mkdir -p "$FORNIX_HOME/.cache/"
# connect the nix cache to prevent duplicates
if ! [ -d "$HOME/.cache/nix/" ]
then
    mkdir -p "$HOME/.cache/nix/"
fi

rm -rf "$FORNIX_HOME/.cache/nix" 2>/dev/null
rm -f "$FORNIX_HOME/.cache/nix" 2>/dev/null
ln -s "$HOME/.cache/nix/" "$FORNIX_HOME/.cache/nix"

# if there are arguments, treat it as a run command
if [ "$FORNIX_DEBUG" = "true" ]; then
    echo "switching from Bash to Zsh"
    echo "changing HOME to temp folder for nix-shell"
fi
export TMPDIR="/tmp" # fixes some build problems (workaround for a bug in Nix)
__temp_var__nix_shell_file="$FORNIX_FOLDER/settings/extensions/nix/shell.nix"
if [[ -n "$FORNIX_ARGS" ]]
then
    # FIXME: I think the single quotes need to be escaped from the arguments (need to iterate over them, escape each one with single quotes)
    # run single command
    if [ "$FORNIX_DEBUG" = "true" ]; then
        echo "running nix-shell"
    fi
    HOME="$FORNIX_HOME" nix-shell --pure --show-trace --run "zsh -c '$FORNIX_ARGS'" "$__temp_var__nix_shell_file" -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/a7ecde854aee5c4c7cd6177f54a99d2c1ff28a31.tar.gz --keep __FORNIX_NIX_SETTINGS_PATH --keep __FORNIX_NIX_MAIN_CODE_PATH --keep __FORNIX_NIX_PACKAGES_FILE_PATH --keep __FORNIX_NIX_PATH_EXPORT_FILE --keep __FORNIX_NIX_COMMANDS --keep FORNIX_FOLDER --keep NIX_STORE_DIR
else
    if [ "$FORNIX_DEBUG" = "true" ]; then
        echo "running nix-shell"
    fi
    # run the install right before because it shows output while installing (nix-shell is silent)
    HOME="$FORNIX_HOME" nix-shell -v --pure --show-trace --command "zsh" "$__temp_var__nix_shell_file" -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/a7ecde854aee5c4c7cd6177f54a99d2c1ff28a31.tar.gz --keep __FORNIX_NIX_SETTINGS_PATH --keep __FORNIX_NIX_MAIN_CODE_PATH --keep __FORNIX_NIX_PACKAGES_FILE_PATH --keep __FORNIX_NIX_PATH_EXPORT_FILE --keep __FORNIX_NIX_COMMANDS --keep FORNIX_FOLDER --keep NIX_STORE_DIR
fi
if [ "$FORNIX_DEBUG" = "true" ]; then
    echo "exited the nix-shell environment"
    echo '(Tools/Commands mentioned in "settings/extensions/nix/nix.toml" are no longer available/installed)'
    echo ""
    echo "switched from Zsh back to Bash"
    echo "finished: $FORNIX_COMMANDS_FOLDER"shell
fi
unset __temp_var__nix_shell_file
unset __temp_var__cache_folder